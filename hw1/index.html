<!DOCTYPE html>
<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			body {
				font-family: 'Inter', sans-serif;
				line-height: 1.6;
				color: #333;
				background-color: #fff;
			}

			.container {
				margin: 0 auto;
				padding: 60px 15%;
			}

			h1, h2, h3 {
				color: #1a1a1a;
			}

			h1 {
				text-align: center;
				border-bottom: 2px solid #eee;
				padding-bottom: 20px;
			}

			h2 {
				margin-top: 40px;
				border-left: 5px solid #0055ff;
				padding-left: 15px;
			}

			p {
				margin-bottom: 20px;
			}

			figure {
				text-align: center;
				margin: 30px 0;
			}

			img {
				display: inline-block;
				max-width: 100%;
				height: auto;
				border: 1px solid #ddd;
				border-radius: 8px;
				box-shadow: 0 4px 8px rgba(0,0,0,0.05);
			}

			figcaption {
				font-style: italic;
				font-size: 0.9em;
				color: #666;
				margin-top: 10px;
			}

			/* Task Comparison Grids */
			.image-grid {
				display: flex;
				flex-wrap: wrap;
				justify-content: space-between;
				gap: 20px;
				margin: 20px 0;
			}

			.image-grid figure {
				flex: 1 1 45%;
				min-width: 300px;
				margin: 0;
			}

			.image-grid-3 figure {
				flex: 1 1 30%;
				min-width: 250px;
				margin: 0;
			}

			code {
				background-color: #f4f4f4;
				padding: 2px 5px;
				border-radius: 4px;
				font-family: monospace;
			}

			a {
				color: #0055ff;
				text-decoration: none;
			}

			a:hover {
				text-decoration: underline;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
			<div style="text-align: center; font-weight: 600;">Name: Umesh Gopi</div>

			<div style="text-align: center; margin-top: 10px;">
				Link to webpage: <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a> | 
				Link to GitHub: <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
			</div>

			<h2>Overview</h2>
			<p>
				In this homework, I implemented a basic rasterizer capable of drawing triangles, performing supersampling for antialiasing, applying hierarchical transforms, and mapping textures using various sampling methods. This project provided a hands-on look at the graphics pipeline, from coordinate transformations to the math behind smooth color interpolation and texture filtering.
			</p>

			<h2>Task 1: Drawing Single-Color Triangles</h2>
			<p>
				To rasterize triangles, we first find the bounding box of the triangle by taking the minimum and maximum of the x and y coordinates of the three vertices. We then define the three line equations $L(x,y) = Ax + By + C$ for each edge. By iterating through every pixel center within the bounding box and performing the Three Line Test, we determine if a point lies inside the triangle. If it does, we color the pixel. This method ensures we only process the pixels that could potentially be inside the triangle, making it as efficient as a standard bounding box sampling approach.
			</p>

			<figure>
				<img src="screenshot_2-14_10-18-53.png" alt="Task 1 Screenshot"/>
				<figcaption>Rasterization of basic/test4.svg. The pixel inspector shows the aliased (jagged) edge of a thin triangle at 1 sample per pixel.</figcaption>
			</figure>

			<h2>Task 2: Antialiasing by Supersampling</h2>
			<p>
				For supersampling, I updated the buffer structure to account for multiple samples per pixel. Instead of sampling just the center, we divide each pixel into a sub-grid based on the sampling rate (e.g., $4 \times 4$ for 16x). We iterate through these sub-pixels, perform the line test, and store the results in a larger sample buffer. Finally, when resolving to the frame buffer, we average the colors of the sub-pixels to determine the final pixel color.
			</p>
			<p>
				This process effectively acts as a low-pass filter. As seen in the images below, increasing the sampling rate significantly reduces the "jaggies" on edges. While 16x sampling provides the best quality, 4x sampling offers a strong balance between visual improvement and memory usage.
			</p>

			<div class="image-grid-3">
				<figure>
					<img src="screenshot_2-14_10-16-56.png" alt="Supersampling 1x" />
					<figcaption>1 Sample Per Pixel</figcaption>
				</figure>
				<figure>
					<img src="screenshot_2-14_10-17-9.png" alt="Supersampling 4x" />
					<figcaption>4 Samples Per Pixel</figcaption>
				</figure>
				<figure>
					<img src="screenshot_2-14_10-17-15.png" alt="Supersampling 16x" />
					<figcaption>16 Samples Per Pixel</figcaption>
				</figure>
			</div>

			<h2>Task 3: Transforms</h2>
			<p>
				I modified the original cubeman to perform a friendly waving motion. To achieve this, I applied specific rotation and translation transformations to the right arm components. I also tilted the torso slightly to make the pose appear more dynamic and "in motion" as if the robot is jumping while waving.
			</p>
			
			<figure>
				<img src="screenshot_2-18_16-10-35.png" alt="Waving Robot" style="width:60%"/>
				<figcaption>My updated cubeman (my_robot.svg) waving hello.</figcaption>
			</figure>

			<h2>Task 4: Barycentric coordinates</h2>
			<p>
				Barycentric coordinates allow us to express any point inside a triangle as a weighted average of its vertices. By calculating $\alpha, \beta, \text{ and } \gamma$ based on the relative distances to the edges, we can interpolate any attribute (like color or texture coordinates) smoothly across the triangle's surface.
			</p>
			
			<p>
				Using the equation:
				$$ \text{color} = \alpha \cdot \text{color1} + \beta \cdot \text{color2} + \gamma \cdot \text{color3} $$
				we can create smooth gradients where the color at any point is a perfect blend of the vertex colors.
			</p>

			<div class="image-grid">
				<figure>
					<img src="screenshot_2-18_16-22-39.png" alt="Barycentric Triangle" />
					<figcaption>A single triangle demonstrating smooth color interpolation via barycentric coordinates.</figcaption>
				</figure>
				<figure>
					<img src="screenshot_2-18_16-24-25.png" alt="Test 7 Color Wheel" />
					<figcaption>A screenshot of basic/test7.svg showing the color wheel at 1 sample per pixel.</figcaption>
				</figure>
			</div>

			<h2>Task 5: "Pixel sampling" for texture mapping</h2>
			<p>
				Pixel sampling determines how we fetch colors from a texture map. I implemented this by using barycentric interpolation to find the $(u, v)$ texture coordinates for each pixel. 
			</p>
			
			<p>
				<b>Nearest Sampling:</b> Picks the single closest texel to the $(u, v)$ coordinate. It's fast but causes "blockiness" when magnified. <br>
				<b>Bilinear Sampling:</b> Samples the four nearest texels and performs a weighted average based on the distance. This produces a much smoother result.
			</p>

			<div class="image-grid">
				<figure>
					<img src="screenshot_2-18_17-15-6.png" alt="Nearest 1x" />
					<figcaption>Nearest Sampling, 1 sample/pixel</figcaption>
				</figure>
				<figure>
					<img src="screenshot_2-18_17-15-36.png" alt="Nearest 16x" />
					<figcaption>Nearest Sampling, 16 samples/pixel</figcaption>
				</figure>
				<figure>
					<img src="screenshot_2-18_17-15-57.png" alt="Bilinear 1x" />
					<figcaption>Bilinear Sampling, 1 sample/pixel</figcaption>
				</figure>
				<figure>
					<img src="screenshot_2-18_17-16-22.png" alt="Bilinear 16x" />
					<figcaption>Bilinear Sampling, 16 samples/pixel</figcaption>
				</figure>
			</div>
			<p>
				Bilinear sampling clearly outperforms nearest sampling in areas of high magnification or high-frequency detail, where nearest sampling creates sharp, stair-step artifacts.
			</p>

			<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
			<p>
				(TODO: Explain level sampling, mipmap implementation, and the tradeoffs between speed, memory, and antialiasing power.)
			</p>

		</div>
	</body>
</html>
