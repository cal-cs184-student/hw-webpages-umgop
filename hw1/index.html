<!DOCTYPE html>
<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
				margin: 20px 0;
			}

			img {
				display: inline-block;
				max-width: 100%;
			}

			body {
				font-family: 'Inter', sans-serif;
				line-height: 1.6;
			}

			.image-grid {
				display: flex;
				flex-wrap: wrap;
				justify-content: center;
				gap: 10px;
			}

			.image-grid figure {
				flex: 1;
				min-width: 300px;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
			<div style="text-align: center;">Name: Umesh Gopi</div>

			<br>

			<div style="text-align: center;">
				Link to webpage: <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
				<br>
				Link to GitHub repository: <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
			</div>

			<figure>
				<img src="lion.jpg" alt="Lion" style="width:50%"/>
				<figcaption>Example lion image used in the project.</figcaption>
			</figure>

			<h2>Overview</h2>
			<p>Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.</p>

			<h2>Task 1: Drawing Single-Color Triangles</h2>
			<p>To rasterize triangles we first want to find the bounding points of the triangles that we want to sample inside. To do this we get the maximum and minimum of both the x and y points for all 3 given points. After, we want to define the 3 Lines (L(x,y)) that actually make up the triangle so we can use the three Lines Test to properly rasterize our triangles. We can find L(x,y) = Ax + By + C and solve for A, B and C with some math from the points that have been given to us. Then we can iterate through all the points inside of our bounding points and see if the center of each pixel falls inside our triangle. If it does then we can color it in and if not we donâ€™t.</p>
			<p>It is no worse as we are pretty much doing the same type of sampling inside the bounding of the triangle.</p>

			<figure>
				<img src="screenshot_2-14_10-18-53.png" alt="Task 1 Screenshot" />
				<figcaption>Screenshot of basic/test4.svg showing the pixel inspector centered on an aliased edge.</figcaption>
			</figure>

			<h2>Task 2: Antialiasing by Supersampling</h2>
			<p>For the SuperSampling implementation, the main change that I did was account for sampling each pixel multiple times instead of just sampling the pixel at the center every time. I updated the buffer data structure to include the sample rate when being used to account for more values and hence get better definition when displaying the images at a higher sampling rate. The x and y values are the main things that changed when actually doing the rasterizing apart from updating the actual buffer. We include two loops based on the sampling size (N being defined as the square root of the sampling rate) with the x and y values increasing at increments of 1 over the square root of the sample rate, hence covering much more points than before.</p>
			<p>This process is very memory intensive but as we are covering more space we see in the pictures below, as we supersample more the edges are more defined and are not crooked/shaking anymore and it becomes more of a straight line. The effect is most noticeable from 1 sample to 4 samples, but still a very minor improvement from 4 samples to 16 samples. I personally would supersample at 4 per pixel as it gives the best balance between memory and actual output image wise.</p>

			<div class="image-grid">
				<figure>
					<img src="screenshot_2-14_10-16-56.png" alt="1x Sampling" />
					<figcaption>Sample rate: 1</figcaption>
				</figure>
				<figure>
					<img src="screenshot_2-14_10-17-9.png" alt="4x Sampling" />
					<figcaption>Sample rate: 4</figcaption>
				</figure>
				<figure>
					<img src="screenshot_2-14_10-17-15.png" alt="16x Sampling" />
					<figcaption>Sample rate: 16</figcaption>
				</figure>
			</div>

			<h2>Task 3: Transforms</h2>
			<p>In this image the robot will be waving his hand at the user while jumping.</p>

			<figure>
				<img src="screenshot_2-18_16-10-35.png" alt="Waving Robot" />
				<figcaption>Modified robot.svg with the cubeman in a waving and jumping pose.</figcaption>
			</figure>

			<h2>Task 4: Barycentric coordinates</h2>
			<p>Baycentric Interpolation is based on using the points color at 3 points of the triangle and in a way combining them to form a new color value inside the triangle based on its position. We do this by calculating alpha, beta and gamma which are derived from the area of the triangle as well as the dx,dy of the lines of the triangle. We use these derived values to interpolate the colors in this equation alpha * color1 + betta * color2 + gamma * color3.</p>

			<div class="image-grid">
				<figure>
					<img src="screenshot_2-18_16-22-39.png" alt="Barycentric Triangle" />
					<figcaption>Example of color interpolation in a single triangle.</figcaption>
				</figure>
				<figure>
					<img src="screenshot_2-18_16-24-25.png" alt="Test 7 Color Wheel" />
					<figcaption>Screenshot of basic/test7.svg with sample rate 1.</figcaption>
				</figure>
			</div>

			<h2>Task 5: "Pixel sampling" for texture mapping</h2>
			<p>Pixel sampling is how we figure out the color of each pixel when applying a texture to a triangle. I implemented it by first computing the texture coordinates for each pixel using barycentric interpolation, then fetching the color from the texture. In nearest sampling, I simply pick the color of the closest texel, which is fast but can look blocky or jagged, especially on detailed or magnified textures. In bilinear sampling, I take the four nearest texels and average their colors based on distance, which smooths out edges and makes textures look much nicer. I also added supersampling by taking multiple samples per pixel to reduce aliasing. Comparing screenshots, nearest sampling at 1 sample per pixel looks jagged, while increasing to 16 samples improves it slightly. Bilinear sampling at 1 sample per pixel already looks much smoother, and combining it with 16 samples per pixel produces the clearest, smoothest result. The biggest difference between nearest and bilinear shows up on high-frequency textures or magnified areas, where nearest can look blocky and bilinear keeps edges smooth.</p>

			<div class="image-grid">
				<figure>
					<img src="screenshot_2-18_17-15-6.png" alt="Nearest 1x" />
					<figcaption>Nearest sampling at 1 sample per pixel.</figcaption>
				</figure>
				<figure>
					<img src="screenshot_2-18_17-15-36.png" alt="Nearest 16x" />
					<figcaption>Nearest sampling at 16 samples per pixel.</figcaption>
				</figure>
			</div>
			<div class="image-grid">
				<figure>
					<img src="screenshot_2-18_17-15-57.png" alt="Bilinear 1x" />
					<figcaption>Bilinear sampling at 1 sample per pixel.</figcaption>
				</figure>
				<figure>
					<img src="screenshot_2-18_17-16-22.png" alt="Bilinear 16x" />
					<figcaption>Bilinear sampling at 16 samples per pixel.</figcaption>
				</figure>
			</div>

			<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
			<p>Level sampling is a way to choose which mipmap level to use when fetching a texture, based on how much a pixel covers in texture space. I implemented it by calculating the level of detail (LOD) for each pixel and then selecting the appropriate mipmap: L_ZERO always uses the base texture, while L_NEAREST picks the closest mipmap level based on the LOD. This works together with pixel sampling, so each pixel can use nearest or bilinear interpolation at that mipmap level. The tradeoffs are straightforward: L_ZERO with pixel sampling is fastest but can produce aliasing on minified textures, while L_NEAREST reduces aliasing at the cost of extra memory and some computation. Bilinear sampling smooths colors but is slower than nearest, and supersampling increases quality further but is very memory-intensive. I rendered four versions of my texture using the combinations of L_ZERO + P_NEAREST, L_ZERO + P_LINEAR, L_NEAREST + P_NEAREST, and L_NEAREST + P_LINEAR. The results clearly show that using L_NEAREST reduces aliasing for distant or small textures, and combining it with bilinear sampling produces the smoothest and most visually appealing result.</p>

			<div class="image-grid">
				<figure>
					<img src="screenshot_2-18_22-36-53.png" alt="L_ZERO P_NEAREST" />
					<figcaption>L_ZERO and P_NEAREST</figcaption>
				</figure>
				<figure>
					<img src="screenshot_2-18_22-37-45.png" alt="L_ZERO P_LINEAR" />
					<figcaption>L_ZERO and P_LINEAR</figcaption>
				</figure>
			</div>
			<div class="image-grid">
				<figure>
					<img src="screenshot_2-18_22-39-50.png" alt="L_NEAREST P_NEAREST" />
					<figcaption>L_NEAREST and P_NEAREST</figcaption>
				</figure>
				<figure>
					<img src="screenshot_2-18_22-38-43.png" alt="L_NEAREST P_LINEAR" />
					<figcaption>L_NEAREST and P_LINEAR</figcaption>
				</figure>
			</div>
		</div>
	</body>
</html>
